// Copyright 2019 Rich Heslip
//
// Author: Rich Heslip 
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// 
// See http://creativecommons.org/licenses/MIT/ for more information.
//
// -----------------------------------------------------------------------------
//
// 
// sample player inspired by Jan Ostman's ESP8266 drum machine http://janostman.wordpress.com
// completely rewritten for the Motivation Radio Eurorack module
// plays samples in response to gate/trigger inputs and MIDI note on messages
// will play any 22khz sample file converted to a header file in the appropriate format
// Feb 3/19 - initial version
// Feb 11/19 - sped up encoder/trigger ISR so it will catch 1ms pulses from Grids
// Jan 2023 - porting code to Pi Pico so I can use it on a 16mb flash version
// ditching the display, just using encoder and LEDs for a UI

#include <Arduino.h> 

//#include <WiFi.h>
//#include <i2s.h>
//#include <i2s_reg.h>
//#include <pgmspace.h>
//#include "driver/i2s.h"
//#include "freertos/queue.h"
#include <Wire.h>
#include <Adafruit_GFX.h>
//#include <Adafruit_SSD1306.h>
#include <SH1106.h>
//#include "MIDI.h"
#include "io.h"
#include <I2S.h>
#include "RPi_Pico_TimerInterrupt.h"
#include "Clickencoder.h"

#define OLED_RESET -1
Adafruit_SH1106 display(OLED_RESET); // display

#define SAMPLERATE 22050

I2S DAC(OUTPUT);  // using PT8211 stereo DAC


/* no MIDI for now
// MIDI stuff
uint8_t MIDI_Channel=10;  // default MIDI channel for percussion
struct SerialMIDISettings : public midi::DefaultSettings
{
  static const long BaudRate = 31250;
};


// must use HardwareSerial for extra UARTs
HardwareSerial MIDISerial(2);

// instantiate the serial MIDI library
MIDI_CREATE_CUSTOM_INSTANCE(HardwareSerial, MIDISerial, MIDI, SerialMIDISettings);
*/

// encoder 
ClickEncoder Encoder2(R_ENC_A,R_ENC_B,R_SW,4); // divide by 4 works best with my encoder
  
// sample interrupt timer defs

#define ENC_TIMER_MICROS 250 // 4khz for encoder
// Init RPI_PICO_Timer
RPI_PICO_Timer ITimer(0);

// ADC readings
#define ADC_RANGE 4097  // 12 bit ADC
uint16_t CV_in[4];

// we have four voices that can play any sample when triggered by the Gate inputs
// this structure holds the settings for each voice

enum CV_MODE {NONE,VOLUME,SAMPLE};

#define NUM_VOICES 8
struct voice_t {
  int16_t sample;   // menusystem requires ints
  int16_t level;   // 0-1000, shown as a float hown as a float -1 to 1.0
  int16_t pan;     // -1000 to 1000, shown as a float -1 to 1.0
  int16_t cv_mode;
  uint8_t mix;   /// for testing till I figure out how this works again!
} voice[NUM_VOICES] = {
  0,      // default voice 0 assignment 
  1000, 
  0,
  127,    // max volume
  NONE,   // CV not assigned
  
  3,      // default voice 1 assignment 
  1000, 
  0,
   127,    // max volume
  NONE,   // CV not assigned
  
  5,    // default voice 2 assignment 
  1000, 
  0,
  127,    // max volume
  NONE,   // CV not assigned
  
  7,    // default voice 3 assignment 
  1000, 
  0,
  127,   // max volume
  NONE,   // CV not assigned

  9,    // default voice 4 assignment 
  1000, 
  0,
  127,   // max volume
  NONE,   // CV not assigned

  11,    // default voice 5 assignment 
  1000, 
  0,
  127,   // max volume
  NONE,   // CV not assigned  

  13,    // default voice 6 assignment 
  1000, 
  0,
  127,   // max volume
  NONE,   // CV not assigned

  17,    // default voice 7 assignment 
  1000, 
  0,
  127,   // max volume
  NONE,   // CV not assigned
  };  


// we can have an arbitrary number of samples but youl will run out of memory (or CPU) at some point
// sound sample files must be 22khz 16 bit signed PCM format - see the sample include files for examples
// sample files are compiled into arrays and stored in program flash
// if your sketch is too big you may have to fiddle with the flash partition scheme to enable more of the flash to be used for program space

// the header files can be auto generated by the wav2header utility
// put your 22khz or 44khz PCM wav files in a sample directory, run the utility and it will generate all the header files
#include "GMsamples/samples.h"  // general MIDI set - do not run wav2header on these or it will mess up the midi mapping
// #include "808samples/samples.h" // 808 sounds
//#include "PNSsamples/samples.h"   // PNS soundfont set
//#include "Angular_Jungle_Set/samples.h"   // Jungle soundfont set - great!
//#include "WSA1_DRUMKIT/samples.h"   // WSA1 soundfont set
//#include "Angular_Techno_Set/samples.h"   // Techno

#define NUM_SAMPLES (sizeof(sample)/sizeof(sample_t))


// encoder timer interrupt handler 
// we also sample the gate/trigger inputs and trigger sample playback

// trigger counters
// the CV inputs are sampled at a different rate which could cause an "accent" input to be missed due to timing skew
// so we trigger the sample the second time we see the gate active

uint8_t trigcnt[NUM_VOICES] = {0,0,0,0,0,0,0,0}; // trigger counters
//uint8_t trigcnt[NUM_VOICES] = {0,0,0,0}; // trigger counters

bool TimerHandler0(struct repeating_timer *t)
{
  (void) t;
  
  uint8_t sample_toplay,volume_toplay;
  uint32_t offset;
   
  Encoder2.service();    // check the encoder inputs

 // handle drum triggers
  bool trigger;
  for (int i=0; i< NUM_VOICES;++i) {
    switch (i) { // sample gate inputs
      case 0:
        trigger=digitalRead(GATE0); // active low gate inputs
        break;
      case 1:
        trigger=digitalRead(GATE1);
        break; 
      case 2:
        trigger=digitalRead(GATE2);
        break;
      case 3:
        trigger=digitalRead(GATE3);
        break;
      case 4:
        trigger=digitalRead(GATE4);
        break;
      case 5:
        trigger=digitalRead(GATE5);
        break;
       case 6:
        trigger=digitalRead(GATE6);
        break;
      case 7:
        trigger=digitalRead(GATE7);
        break;
    }
    
    if (trigger) { 
      if (trigcnt[i]<=3) ++trigcnt[i];
      if (trigcnt[i]==2) { // trigger on second sample of gate active
      sample_toplay=voice[i].sample;  // default sample to play
//      volume_toplay=voice[i].mix;     // default volume level to play
      volume_toplay=127*voice[i].level/1000;     // default volume level to play
        switch (voice[i].cv_mode) { // handle CV inputs
          case NONE:
            break;
          case VOLUME:
            //volume_toplay=(voice[i].mix*CV_in[i]*CV_in[i]/(ADC_RANGE*ADC_RANGE)); // set play volume from mix level and CV in - square law response gives more punch
            volume_toplay=(voice[i].mix*CV_in[i]/ADC_RANGE*ADC_RANGE); // set play volume from mix level and CV in 
            break;
          case SAMPLE:
            offset=CV_in[i]*NUM_SAMPLES/ADC_RANGE+NUM_SAMPLES/2+1;  // 0V in = sample selected in menu
            sample_toplay=(sample_toplay+(uint8_t)offset) % NUM_SAMPLES; // select sample using CV as an offset into the sample table
            break; 
          default:
            voice[i].cv_mode=NONE;  // if its messed up fix it        
        }
        sample[voice[i].sample].play_volume=volume_toplay;  // set volume
        sample[sample_toplay].sampleindex=0; // start sample playback on selected sample
      }
    }
    else trigcnt[i]=0;
  }
  return true;
}

/* no MIDI for now
// serial MIDI handler

void HandleNoteOn(uint8_t channel, uint8_t note, uint8_t velocity) {
  if (channel==MIDI_Channel) {
      for (int i=0; i< NUM_SAMPLES;++i) {  // 
        if (sample[i].MIDINOTE == note) {
          sample[i].play_volume=velocity;  // use MIDI volume
          sample[i].sampleindex=0;  // if note matches sample MIDI note number, start it playing 
        }
      }
  }
}
*/

#include "menusystem.h" // to avoid forward references

// main core setup
void setup() {
//  WiFi.forceSleepBegin();             


 Serial.begin(115200);

 Serial.print("Number of Samples ");
 Serial.println(NUM_SAMPLES);      

  Wire.setSDA(8);  // I2C pins to use on Pico
  Wire.setSCL(9);
  // by default, we'll generate the high voltage from the 3.3v line internally! (neat!)
  display.begin(SH1106_SWITCHCAPVCC, 0x3C);  // initialize with the I2C addr 0x3D (for the 128x64)

 /* 
  WiFi.begin(ssid, pass);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }

 // Serial.print(F("IP address is ")); 
 // Serial.println(WiFi.localIP()); 


  AppleMIDI.begin("MORAD"); // 'MORAD' will show up as the session name

  AppleMIDI.OnReceiveNoteOn(OnAppleMidiNoteOn);
  */
// set up I/O pins
 
   pinMode(13, OUTPUT); // for monitoring CPU usage
   
  pinMode(GATE0, INPUT_PULLDOWN);
  pinMode(GATE1, INPUT_PULLDOWN);
  pinMode(GATE2, INPUT_PULLDOWN);
  pinMode(GATE3, INPUT_PULLDOWN);
  pinMode(GATE4, INPUT_PULLDOWN);
  pinMode(GATE5, INPUT_PULLDOWN);
  pinMode(GATE6, INPUT_PULLDOWN);
  pinMode(GATE7, INPUT_PULLDOWN);

// set up Pico I2S for PT8211 stereo DAC
	DAC.setBCLK(BCLK);
	DAC.setDATA(I2S_DATA);
	DAC.setBitsPerSample(16);
	DAC.setBuffers(1, 128, 0); // DMA buffer - 32 bit L/R words
	DAC.setLSBJFormat();  // needed for PT8211 which has funny timing
	DAC.begin(SAMPLERATE);

/* no MIDI for now	
//  Set up serial MIDI port
  MIDISerial.begin(31250, SERIAL_8N1, MIDIRX,MIDITX ); // midi port

  // set up serial MIDI library callbacks
  MIDI.setHandleNoteOn(HandleNoteOn);  // 

  // Initiate serial MIDI communications, listen to all channels
  MIDI.begin(MIDI_CHANNEL_OMNI);
  */
  
// set up timer interrupt to sample triggers and encoder
  // Interval in unsigned long microseconds
  if (ITimer.attachInterruptInterval(ENC_TIMER_MICROS, TimerHandler0))
    Serial.println("Started ITimer OK");
  else
    Serial.println("Can't set ITimer. Select another freq. or timer");

  display.clearDisplay();
// text display tests
  display.setTextSize(1);

	display.setTextColor(WHITE,BLACK); // foreground, background  
  display.setCursor(10,30);
  display.println("Pico Drums");
  display.display();
  delay(2000);
  display.clearDisplay(); 
  display.display(); 

  // init the menu system
	menutitle=maintitle;
	drawtopmenu(0);
	drawselector(topmenuindex);    
}


// main core handles UI
void loop() {
  
 // MIDI.read();  // do serial MIDI
 domenus();
 //sample[3].sampleindex=0; // fake a trigger
  
}

// second core setup
// second core dedicated to sample processing
void setup1() {
delay (1000); // wait for main core to start up perhipherals
}

// second core calculates samples and sends to DAC
void loop1(){
  int32_t samplesum=0;
  int32_t index,phase;
  int16_t samp0,samp1,delta;
  
  for (int i=0; i< NUM_SAMPLES;++i) {  // look for samples that are playing, scale their volume, and add them up
// broken integer interpolation code for timing purposes
// if stereo you have to do this twice but you can reuse the interpolation values
/*
    samp0= sample[i].samplearray[index>>20]; // starting sample
    index+=phase; // 20:12 integer:fraction allows for 2**20 samples // index amd phase have to be per sample. phase=1<<12 is normal playback
    samp1=sample[i].samplearray[index>>20]; // next sample
    delta=samp1-samp0;
    samp0=samp0+delta*(index>>20/4096); // not right but Ok for timing
   if (sample[i].sampleindex < sample[i].samplesize) samplesum+=(int32_t)(samp0*sample[i].play_volume);  // 
   */
// original code - complex expression seems to slow the code down somewhat vs above
    if (sample[i].sampleindex < sample[i].samplesize) samplesum+=(int32_t)(sample[i].samplearray[sample[i].sampleindex++]*sample[i].play_volume);  // thats a mouthful!
 
  }
  samplesum=samplesum>>7;  // adjust for play_volume multiply above
  if  (samplesum>32767) samplesum=32767; // clip if sample sum is too large
  if  (samplesum<-32767) samplesum=-32767;
  //samplesum+=32768; // convert to unsigned for DAC output
  
  digitalWrite(13,0); // low = CPU not busy
 // write samples to DMA buffer - this is a blocking call so it stalls when buffer is full
	DAC.write(int16_t(samplesum)); // left
	DAC.write(int16_t(samplesum)); // right
  digitalWrite(13,1); // hi = CPU busy
}


